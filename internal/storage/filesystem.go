package storage

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
)

// FileSystemStorage implements Storage interface using file system
type FileSystemStorage struct {
	reportsPath string
	parser      *ReportParser
}

// NewFileSystemStorage creates a new file system storage
func NewFileSystemStorage(reportsPath string) (*FileSystemStorage, error) {
	if reportsPath == "" {
		return nil, fmt.Errorf("reports path not configured")
	}

	// Ensure reports directory exists
	if err := os.MkdirAll(reportsPath, 0755); err != nil {
		return nil, fmt.Errorf("failed to create reports directory: %w", err)
	}

	return &FileSystemStorage{
		reportsPath: reportsPath,
		parser:      NewReportParser(reportsPath),
	}, nil
}

// SaveScreenshot saves a screenshot record (generates report file)
// This is handled by executor.saveReport, so we just return nil here
func (s *FileSystemStorage) SaveScreenshot(record *ScreenshotRecord) error {
	// Screenshot reports are generated by executor.saveReport
	// We don't need to do anything here as the file is already written
	return nil
}

// UpdateScreenshotAnalysis updates the analysis field in a screenshot report
// Note: This requires scanning, but we can optimize by checking recent directories first
func (s *FileSystemStorage) UpdateScreenshotAnalysis(id, analysis string) error {
	// Find the report file by scanning for the screenshot ID
	// Optimize: start from recent dates and work backwards
	reportPath, err := s.findScreenshotReportByID(id)
	if err != nil {
		return fmt.Errorf("failed to find screenshot report: %w", err)
	}

	if reportPath == "" {
		return fmt.Errorf("screenshot report not found for ID: %s", id)
	}

	// Parse existing report
	parsed, err := s.parser.ParseScreenshotReport(reportPath)
	if err != nil {
		return fmt.Errorf("failed to parse report: %w", err)
	}

	// Update analysis/summary
	parsed.Summary = analysis

	// Regenerate report file
	return s.writeScreenshotReport(reportPath, parsed)
}

// GetScreenshotsByHourKey gets all screenshots for a specific hour
func (s *FileSystemStorage) GetScreenshotsByHourKey(hourKey string) ([]*ScreenshotRecord, error) {
	// Parse hour key: YYYY-MM-DD-HH
	parts := strings.Split(hourKey, "-")
	if len(parts) != 4 {
		return nil, fmt.Errorf("invalid hour key format: %s", hourKey)
	}

	year, month, day, hour := parts[0], parts[1], parts[2], parts[3]

	// Build directory path: reports/YYYY/MM/DD/HH/
	hourDir := filepath.Join(s.reportsPath, year, month, day, hour)

	// Check if directory exists
	if _, err := os.Stat(hourDir); os.IsNotExist(err) {
		return []*ScreenshotRecord{}, nil
	}

	// Read all minute-level report files (MM.md format)
	entries, err := os.ReadDir(hourDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read hour directory: %w", err)
	}

	var records []*ScreenshotRecord
	screenshotPattern := regexp.MustCompile(`^\d{2}\.md$`)

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		filename := entry.Name()
		if !screenshotPattern.MatchString(filename) {
			continue
		}

		reportPath := filepath.Join(hourDir, filename)
		parsed, err := s.parser.ParseScreenshotReport(reportPath)
		if err != nil {
			// Skip files that can't be parsed
			continue
		}

		record := &ScreenshotRecord{
			ID:        parsed.ScreenshotID,
			Timestamp: parsed.StartTime,
			ScreenID:  parsed.ScreenID,
			ImagePath: parsed.ImagePath,
			Analysis:  parsed.Summary,
			HourKey:   hourKey,
		}

		records = append(records, record)
	}

	// Sort by timestamp
	sort.Slice(records, func(i, j int) bool {
		return records[i].Timestamp.Before(records[j].Timestamp)
	})

	return records, nil
}

// GetScreenshotsByIDs gets screenshots by their IDs
func (s *FileSystemStorage) GetScreenshotsByIDs(ids []string) (map[string]*ScreenshotRecord, error) {
	result := make(map[string]*ScreenshotRecord)

	// Scan all report files to find matching IDs
	err := filepath.Walk(s.reportsPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // Skip errors
		}

		if info.IsDir() {
			return nil
		}

		// Check if it's a screenshot report
		filename := info.Name()
		screenshotPattern := regexp.MustCompile(`^\d{2}\.md$`)
		if !screenshotPattern.MatchString(filename) {
			return nil
		}

		parsed, err := s.parser.ParseScreenshotReport(path)
		if err != nil {
			return nil // Skip unparseable files
		}

		// Check if this ID is in our list
		for _, id := range ids {
			if parsed.ScreenshotID == id {
				record := &ScreenshotRecord{
					ID:        parsed.ScreenshotID,
					Timestamp: parsed.StartTime,
					ScreenID:  parsed.ScreenID,
					ImagePath: parsed.ImagePath,
					Analysis:  parsed.Summary,
					HourKey:   parsed.HourKey,
				}
				result[id] = record
				break
			}
		}

		return nil
	})

	return result, err
}

// GetHourSummary gets hour summary (not used in file system, return nil)
func (s *FileSystemStorage) GetHourSummary(hourKey string) (*HourSummary, error) {
	// Hour summaries are not stored separately in file system
	// They can be generated from hour.md files if needed
	return nil, nil
}

// SaveHourSummary saves hour summary (not used in file system)
func (s *FileSystemStorage) SaveHourSummary(summary *HourSummary) error {
	// Hour summaries are not stored separately in file system
	return nil
}

// UpdateHourSummary updates hour summary (not used in file system)
func (s *FileSystemStorage) UpdateHourSummary(hourKey string, screenshotIDs []string, summary string) error {
	// Hour summaries are not stored separately in file system
	return nil
}

// QueryByDateRange queries screenshots by date range
func (s *FileSystemStorage) QueryByDateRange(start, end time.Time) ([]*ScreenshotRecord, error) {
	var records []*ScreenshotRecord

	// Calculate date range
	current := start
	for current.Before(end) || current.Equal(end) {
		year := current.Format("2006")
		month := current.Format("01")
		day := current.Format("02")

		// Scan all hours in this day
		dayDir := filepath.Join(s.reportsPath, year, month, day)
		if _, err := os.Stat(dayDir); os.IsNotExist(err) {
			current = current.AddDate(0, 0, 1)
			continue
		}

		hourEntries, err := os.ReadDir(dayDir)
		if err != nil {
			current = current.AddDate(0, 0, 1)
			continue
		}

		for _, hourEntry := range hourEntries {
			if !hourEntry.IsDir() {
				continue
			}

			hourDir := filepath.Join(dayDir, hourEntry.Name())
			minuteEntries, err := os.ReadDir(hourDir)
			if err != nil {
				continue
			}

			screenshotPattern := regexp.MustCompile(`^\d{2}\.md$`)
			for _, minuteEntry := range minuteEntries {
				if minuteEntry.IsDir() {
					continue
				}

				filename := minuteEntry.Name()
				if !screenshotPattern.MatchString(filename) {
					continue
				}

				reportPath := filepath.Join(hourDir, filename)
				parsed, err := s.parser.ParseScreenshotReport(reportPath)
				if err != nil {
					continue
				}

				// Check if timestamp is in range
				if parsed.StartTime.Before(start) || parsed.StartTime.After(end) {
					continue
				}

				record := &ScreenshotRecord{
					ID:        parsed.ScreenshotID,
					Timestamp: parsed.StartTime,
					ScreenID:  parsed.ScreenID,
					ImagePath: parsed.ImagePath,
					Analysis:  parsed.Summary,
					HourKey:   parsed.HourKey,
				}

				records = append(records, record)
			}
		}

		current = current.AddDate(0, 0, 1)
	}

	// Sort by timestamp
	sort.Slice(records, func(i, j int) bool {
		return records[i].Timestamp.Before(records[j].Timestamp)
	})

	return records, nil
}

// QueryHourSummariesByDateRange queries hour summaries by date range
func (s *FileSystemStorage) QueryHourSummariesByDateRange(start, end time.Time) ([]*HourSummary, error) {
	// Hour summaries are not stored separately in file system
	// Return empty list
	return []*HourSummary{}, nil
}

// GetUnanalyzedScreenshots gets screenshots without analysis
func (s *FileSystemStorage) GetUnanalyzedScreenshots(limit int) ([]*ScreenshotRecord, error) {
	var records []*ScreenshotRecord

	err := filepath.Walk(s.reportsPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}

		if info.IsDir() {
			return nil
		}

		if len(records) >= limit {
			return filepath.SkipAll
		}

		filename := info.Name()
		screenshotPattern := regexp.MustCompile(`^\d{2}\.md$`)
		if !screenshotPattern.MatchString(filename) {
			return nil
		}

		parsed, err := s.parser.ParseScreenshotReport(path)
		if err != nil {
			return nil
		}

		// Check if analysis is empty or indicates failure
		if parsed.Summary == "" || strings.HasPrefix(parsed.Summary, "Analysis failed") {
			record := &ScreenshotRecord{
				ID:        parsed.ScreenshotID,
				Timestamp: parsed.StartTime,
				ScreenID:  parsed.ScreenID,
				ImagePath: parsed.ImagePath,
				Analysis:  parsed.Summary,
				HourKey:   parsed.HourKey,
			}
			records = append(records, record)
		}

		return nil
	})

	// Sort by timestamp
	sort.Slice(records, func(i, j int) bool {
		return records[i].Timestamp.Before(records[j].Timestamp)
	})

	return records, err
}

// SavePeriodSummary saves a period summary to a report file
func (s *FileSystemStorage) SavePeriodSummary(summary *PeriodSummary) error {
	reportPath, err := s.calculateReportPath(summary)
	if err != nil {
		return fmt.Errorf("failed to calculate report path: %w", err)
	}

	// Ensure directory exists
	dir := filepath.Dir(reportPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Generate report content
	content := s.generatePeriodReportContent(summary)

	// Remove existing file if it exists to ensure complete overwrite
	if _, err := os.Stat(reportPath); err == nil {
		if err := os.Remove(reportPath); err != nil {
			return fmt.Errorf("failed to remove existing report file: %w", err)
		}
	}

	// Write file (complete overwrite)
	if err := os.WriteFile(reportPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write report file: %w", err)
	}

	// Clear cache for this file
	s.parser.ClearCacheForFile(reportPath)

	return nil
}

// GetPeriodSummary gets a period summary by period key
func (s *FileSystemStorage) GetPeriodSummary(periodKey string) (*PeriodSummary, error) {
	// Build report path directly from period key
	reportPath, periodType, err := s.buildReportPathFromPeriodKey(periodKey)
	if err != nil {
		return nil, fmt.Errorf("failed to build report path: %w", err)
	}

	// Check if file exists
	if _, err := os.Stat(reportPath); os.IsNotExist(err) {
		return nil, nil // Not found
	}

	// Parse the report file
	parsed, err := s.parser.ParsePeriodReport(reportPath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse report: %w", err)
	}

	// Convert to PeriodSummary
	summary := &PeriodSummary{
		PeriodKey:   periodKey,
		PeriodType:  parsed.PeriodType,
		StartTime:   parsed.StartTime,
		EndTime:     parsed.EndTime,
		Screenshots: "", // We don't store screenshot IDs in report files
		Summary:     parsed.Summary,
		Analysis:    parsed.Analysis,
	}

	// If period type doesn't match, try to infer from parsed data
	if periodType != "" && parsed.PeriodType != periodType {
		summary.PeriodType = parsed.PeriodType
	}

	return summary, nil
}

// DeletePeriodSummary deletes a period summary report file
func (s *FileSystemStorage) DeletePeriodSummary(periodKey string) error {
	// Build report path directly from period key
	reportPath, _, err := s.buildReportPathFromPeriodKey(periodKey)
	if err != nil {
		return fmt.Errorf("failed to build report path: %w", err)
	}

	// Check if file exists
	if _, err := os.Stat(reportPath); os.IsNotExist(err) {
		return nil // Already deleted
	}

	// Clear cache
	s.parser.ClearCacheForFile(reportPath)

	// Delete file
	return os.Remove(reportPath)
}

// QueryPeriodSummaries queries period summaries by type and date range
func (s *FileSystemStorage) QueryPeriodSummaries(periodType string, start, end time.Time) ([]*PeriodSummary, error) {
	var summaries []*PeriodSummary

	// Build directory paths based on period type and date range
	dirsToScan := s.buildDirectoriesForPeriodType(periodType, start, end)

	// Determine filename pattern based on period type
	var filenamePattern *regexp.Regexp
	switch periodType {
	case "day":
		filenamePattern = regexp.MustCompile(`^day\.md$`)
	case "hour":
		filenamePattern = regexp.MustCompile(`^hour\.md$`)
	case "fifteenmin":
		filenamePattern = regexp.MustCompile(`^fifteenmin-\d+\.md$`)
	case "halfhour":
		filenamePattern = regexp.MustCompile(`^halfhour-\d+\.md$`)
	case "work-segment":
		filenamePattern = regexp.MustCompile(`^work-segment-\d+\.md$`)
	case "week":
		filenamePattern = regexp.MustCompile(`^week-W\d+\.md$`)
	case "month":
		filenamePattern = regexp.MustCompile(`^month\.md$`)
	case "year":
		filenamePattern = regexp.MustCompile(`^year\.md$`)
	default:
		return nil, fmt.Errorf("unsupported period type: %s", periodType)
	}

	// Scan only the necessary directories
	for _, dir := range dirsToScan {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			continue
		}

		entries, err := os.ReadDir(dir)
		if err != nil {
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}

			filename := entry.Name()
			if !filenamePattern.MatchString(filename) {
				continue
			}

			reportPath := filepath.Join(dir, filename)

			// Parse the report
			parsed, err := s.parser.ParsePeriodReport(reportPath)
			if err != nil {
				continue // Skip unparseable files
			}

			// Check if period type matches
			if parsed.PeriodType != periodType && !strings.HasPrefix(parsed.PeriodType, periodType+"-") {
				continue
			}

			// Check if time range matches query range
			// Match SQLite query logic: start_time >= ? AND end_time <= ?
			// Include if: parsed.StartTime >= start AND parsed.EndTime <= end
			if parsed.StartTime.Before(start) || parsed.EndTime.After(end) {
				continue
			}

			// Extract period key from path
			periodKey, err := ExtractPeriodKeyFromPath(reportPath, periodType)
			if err != nil {
				// Try to extract from filename or use a default
				periodKey = strings.TrimSuffix(filename, ".md")
			}

			// Validate period_key consistency: ensure it matches start_time from file content
			// This prevents mismatched metadata when files are manually moved or renamed
			if !parsed.StartTime.IsZero() {
				// Try to validate period_key against start_time
				if err := ValidatePeriodKeyFromStartTime(periodKey, periodType, parsed.StartTime); err != nil {
					// If validation fails, try to rebuild period_key from start_time
					// This handles cases where file was moved or period_key extraction failed
					correctedKey := BuildPeriodKeyFromStartTime(parsed.StartTime, periodType)
					if correctedKey != "" {
						// Use corrected period_key from file content (more reliable)
						periodKey = correctedKey
					}
					// If correction also fails, log warning but continue with extracted key
					// This ensures we don't lose data even if validation fails
				}
			}

			summary := &PeriodSummary{
				PeriodKey:   periodKey,
				PeriodType:  parsed.PeriodType,
				StartTime:   parsed.StartTime,
				EndTime:     parsed.EndTime,
				Screenshots: "", // We don't store screenshot IDs in report files
				Summary:     parsed.Summary,
				Analysis:    parsed.Analysis,
			}

			summaries = append(summaries, summary)
		}
	}

	// Sort by start time
	sort.Slice(summaries, func(i, j int) bool {
		return summaries[i].StartTime.Before(summaries[j].StartTime)
	})

	return summaries, nil
}

// CleanupOldRecords removes old report files (not implemented for file system)
func (s *FileSystemStorage) CleanupOldRecords(retentionDays int) error {
	// File cleanup can be handled separately if needed
	return nil
}

// DeleteScreenshotsByIDs deletes screenshot reports by IDs
func (s *FileSystemStorage) DeleteScreenshotsByIDs(ids []string) error {
	idMap := make(map[string]bool)
	for _, id := range ids {
		idMap[id] = true
	}

	var deleted int
	err := filepath.Walk(s.reportsPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}

		if info.IsDir() {
			return nil
		}

		filename := info.Name()
		screenshotPattern := regexp.MustCompile(`^\d{2}\.md$`)
		if !screenshotPattern.MatchString(filename) {
			return nil
		}

		parsed, err := s.parser.ParseScreenshotReport(path)
		if err != nil {
			return nil
		}

		if idMap[parsed.ScreenshotID] {
			s.parser.ClearCacheForFile(path)
			if err := os.Remove(path); err == nil {
				deleted++
			} else {
				// Log error but continue
				_ = err
			}
		}

		return nil
	})

	return err
}

// ClearAllSummaries clears all period summary reports (not recommended for file system)
func (s *FileSystemStorage) ClearAllSummaries() error {
	// This would delete all report files, which is dangerous
	// Return error to prevent accidental deletion
	return fmt.Errorf("clearAllSummaries not supported for file system storage")
}

// GetAllScreenshots gets all screenshots
func (s *FileSystemStorage) GetAllScreenshots() ([]*ScreenshotRecord, error) {
	return s.QueryByDateRange(time.Time{}, time.Now().AddDate(100, 0, 0))
}

// Close closes the storage (no-op for file system)
func (s *FileSystemStorage) Close() error {
	return nil
}

// RebuildFromDirectory rebuilds from screenshot directory (not needed for file system)
func (s *FileSystemStorage) RebuildFromDirectory(storagePath string, lockScreenDetector LockScreenDetector) (int, error) {
	// Not applicable for file system storage
	return 0, nil
}

// Helper methods

func (s *FileSystemStorage) calculateReportPath(summary *PeriodSummary) (string, error) {
	var summaryDir string
	var filename string
	periodType := summary.PeriodType

	switch periodType {
	case "year":
		yearDir := summary.StartTime.Format("2006")
		summaryDir = filepath.Join(s.reportsPath, yearDir)
		filename = "year.md"
	case "quarter":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir)
		filename = fmt.Sprintf("quarter-Q%d.md", quarter)
	case "month":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir)
		filename = "month.md"
	case "week":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir)
		// 使用Calendar Week（月内周号）
		day := summary.StartTime.Day()
		weekNum := ((day - 1) / 7) + 1
		filename = fmt.Sprintf("week-W%d.md", weekNum)
	case "work-segment":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		// 计算Calendar Week
		day := summary.StartTime.Day()
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		dayDir := summary.StartTime.Format("02")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir, weekDir, dayDir)
		parts := strings.Split(summary.PeriodKey, "-")
		if len(parts) >= 4 && parts[3] == "segment" {
			segmentNum := parts[4]
			filename = fmt.Sprintf("work-segment-%s.md", segmentNum)
		} else {
			filename = fmt.Sprintf("%s.md", summary.PeriodKey)
		}
	case "day":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		// 计算Calendar Week
		day := summary.StartTime.Day()
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		dayDir := summary.StartTime.Format("02")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir, weekDir, dayDir)
		filename = "day.md"
	case "hour":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		// 计算Calendar Week
		day := summary.StartTime.Day()
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		dayDir := summary.StartTime.Format("02")
		hourDir := summary.StartTime.Format("15")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir, weekDir, dayDir, hourDir)
		filename = "hour.md"
	case "halfhour":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		// 计算Calendar Week
		day := summary.StartTime.Day()
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		dayDir := summary.StartTime.Format("02")
		hourDir := summary.StartTime.Format("15")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir, weekDir, dayDir, hourDir)
		minute := summary.StartTime.Format("04")
		filename = fmt.Sprintf("halfhour-%s.md", minute)
	case "fifteenmin":
		yearDir := summary.StartTime.Format("2006")
		quarter := (int(summary.StartTime.Month())-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthDir := summary.StartTime.Format("01")
		// 计算Calendar Week
		day := summary.StartTime.Day()
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		dayDir := summary.StartTime.Format("02")
		hourDir := summary.StartTime.Format("15")
		summaryDir = filepath.Join(s.reportsPath, yearDir, quarterDir, monthDir, weekDir, dayDir, hourDir)
		minute := summary.StartTime.Format("04")
		filename = fmt.Sprintf("fifteenmin-%s.md", minute)
	default:
		return "", fmt.Errorf("unsupported period type: %s", periodType)
	}

	return filepath.Join(summaryDir, filename), nil
}

func (s *FileSystemStorage) generatePeriodReportContent(summary *PeriodSummary) string {
	var sb strings.Builder

	// Determine report title based on period type
	periodTypeName := map[string]string{
		"year":         "年",
		"quarter":      "季度",
		"month":        "月",
		"week":         "周",
		"day":          "日",
		"hour":         "小时",
		"halfhour":     "半小时",
		"fifteenmin":   "十五分钟",
		"work-segment": "工作时间段",
	}

	title := periodTypeName[summary.PeriodType]
	if title == "" {
		title = summary.PeriodType
	}

	sb.WriteString(fmt.Sprintf("# %s周期总结报告\n\n", title))
	sb.WriteString(fmt.Sprintf("**周期类型**: %s\n\n", summary.PeriodType))
	sb.WriteString(fmt.Sprintf("**开始时间**: %s\n\n", summary.StartTime.Format("2006-01-02 15:04:05")))
	sb.WriteString(fmt.Sprintf("**结束时间**: %s\n\n", summary.EndTime.Format("2006-01-02 15:04:05")))

	// Count screenshots if available
	screenshotCount := 0
	if summary.Screenshots != "" {
		ids := strings.Split(summary.Screenshots, ",")
		for _, id := range ids {
			if strings.TrimSpace(id) != "" {
				screenshotCount++
			}
		}
	}
	sb.WriteString(fmt.Sprintf("**截图数量**: %d\n\n", screenshotCount))
	sb.WriteString("---\n\n")

	// Summary section
	if summary.Summary != "" {
		sb.WriteString("## 事实总结\n\n")
		sb.WriteString(summary.Summary)
		sb.WriteString("\n\n---\n\n")
	}

	// Analysis section
	if summary.Analysis != "" {
		sb.WriteString("## 改进建议\n\n")
		sb.WriteString(summary.Analysis)
		sb.WriteString("\n\n---\n\n")
	}

	// Footer
	sb.WriteString(fmt.Sprintf("*报告生成时间: %s*\n", time.Now().Format("2006-01-02 15:04:05")))

	return sb.String()
}

func (s *FileSystemStorage) writeScreenshotReport(filePath string, parsed *ParsedReport) error {
	var sb strings.Builder

	sb.WriteString("# 截图分析报告\n\n")
	sb.WriteString(fmt.Sprintf("**时间**: %s\n\n", parsed.StartTime.Format("2006-01-02 15:04:05")))
	sb.WriteString(fmt.Sprintf("**截图ID**: %s\n\n", parsed.ScreenshotID))
	sb.WriteString(fmt.Sprintf("**截图路径**: %s\n\n", parsed.ImagePath))
	sb.WriteString(fmt.Sprintf("**屏幕ID**: %d\n\n", parsed.ScreenID))
	sb.WriteString("---\n\n")

	if parsed.Summary != "" {
		sb.WriteString("## 事实总结\n\n")
		sb.WriteString(parsed.Summary)
		sb.WriteString("\n\n")
	}

	sb.WriteString("---\n\n")
	sb.WriteString(fmt.Sprintf("*报告生成时间: %s*\n", time.Now().Format("2006-01-02 15:04:05")))

	return os.WriteFile(filePath, []byte(sb.String()), 0644)
}

func (s *FileSystemStorage) findScreenshotReportByID(id string) (string, error) {
	var foundPath string

	err := filepath.Walk(s.reportsPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}

		if info.IsDir() {
			return nil
		}

		filename := info.Name()
		screenshotPattern := regexp.MustCompile(`^\d{2}\.md$`)
		if !screenshotPattern.MatchString(filename) {
			return nil
		}

		parsed, err := s.parser.ParseScreenshotReport(path)
		if err != nil {
			return nil
		}

		if parsed.ScreenshotID == id {
			foundPath = path
			return filepath.SkipAll
		}

		return nil
	})

	return foundPath, err
}

// buildReportPathFromPeriodKey builds report file path directly from period key
func (s *FileSystemStorage) buildReportPathFromPeriodKey(periodKey string) (string, string, error) {
	// Try common patterns based on period key format
	// For day: 2025-12-02 -> reports/2025/Q4/12/W1/02/day.md
	if matched, _ := regexp.MatchString(`^\d{4}-\d{2}-\d{2}$`, periodKey); matched {
		parts := strings.Split(periodKey, "-")
		year, month, dayStr := parts[0], parts[1], parts[2]
		// Calculate quarter
		monthInt, _ := strconv.Atoi(month)
		quarter := (monthInt-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		// Calculate Calendar Week
		day, _ := strconv.Atoi(dayStr)
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		dayPath := filepath.Join(s.reportsPath, year, quarterDir, month, weekDir, dayStr, "day.md")
		return dayPath, "day", nil
	}

	// For hour: 2025-12-02-10 -> reports/2025/Q4/12/W1/02/10/hour.md
	if matched, _ := regexp.MatchString(`^\d{4}-\d{2}-\d{2}-\d{2}$`, periodKey); matched {
		parts := strings.Split(periodKey, "-")
		year, month, dayStr, hour := parts[0], parts[1], parts[2], parts[3]
		// Calculate quarter
		monthInt, _ := strconv.Atoi(month)
		quarter := (monthInt-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		// Calculate Calendar Week
		day, _ := strconv.Atoi(dayStr)
		weekNum := ((day - 1) / 7) + 1
		weekDir := fmt.Sprintf("W%d", weekNum)
		hourPath := filepath.Join(s.reportsPath, year, quarterDir, month, weekDir, dayStr, hour, "hour.md")
		return hourPath, "hour", nil
	}

	// For week: 2025-12-01-week -> reports/2025/Q4/12/week-W1.md
	if strings.Contains(periodKey, "week") {
		if matched, _ := regexp.MatchString(`^\d{4}-\d{2}-\d{2}-week`, periodKey); matched {
			parts := strings.Split(periodKey, "-")
			year, month, dayStr := parts[0], parts[1], parts[2]
			// Calculate quarter
			monthInt, _ := strconv.Atoi(month)
			quarter := (monthInt-1)/3 + 1
			quarterDir := fmt.Sprintf("Q%d", quarter)
			// Calculate Calendar Week number
			day, err := strconv.Atoi(dayStr)
			if err != nil {
				return "", "week", fmt.Errorf("failed to parse day from period key: %w", err)
			}
			weekNum := ((day - 1) / 7) + 1
			filename := fmt.Sprintf("week-W%d.md", weekNum)
			weekPath := filepath.Join(s.reportsPath, year, quarterDir, month, filename)
			return weekPath, "week", nil
		}
		// If it's just week-W49 format
		if strings.HasPrefix(periodKey, "week-W") {
			re := regexp.MustCompile(`week-W(\d+)`)
			matches := re.FindStringSubmatch(periodKey)
			if len(matches) == 2 {
				// Need to find which month/year this week belongs to
				// For now, scan month directories - this is a limitation
				return "", "week", fmt.Errorf("week key format week-W%s requires scanning, use YYYY-MM-DD-week format instead", matches[1])
			}
		}
	}

	// For month: 2025-12 -> reports/2025/Q4/12/month.md
	if matched, _ := regexp.MatchString(`^\d{4}-\d{2}$`, periodKey); matched {
		parts := strings.Split(periodKey, "-")
		year, month := parts[0], parts[1]
		// Calculate quarter
		monthInt, _ := strconv.Atoi(month)
		quarter := (monthInt-1)/3 + 1
		quarterDir := fmt.Sprintf("Q%d", quarter)
		monthPath := filepath.Join(s.reportsPath, year, quarterDir, month, "month.md")
		return monthPath, "month", nil
	}

	// For year: 2025 -> reports/2025/year.md
	if matched, _ := regexp.MatchString(`^\d{4}$`, periodKey); matched {
		yearPath := filepath.Join(s.reportsPath, periodKey, "year.md")
		return yearPath, "year", nil
	}

	// For work-segment: work-segment-0 -> reports/YYYY/MM/DD/work-segment-0.md
	if strings.HasPrefix(periodKey, "work-segment-") {
		// Need date context, try to find in recent days
		return "", "work-segment", fmt.Errorf("work-segment key requires date context: %s", periodKey)
	}

	return "", "", fmt.Errorf("unable to build path for period key: %s", periodKey)
}

// buildDirectoriesForPeriodType builds list of directories to scan based on period type and date range
func (s *FileSystemStorage) buildDirectoriesForPeriodType(periodType string, start, end time.Time) []string {
	var dirs []string

	switch periodType {
	case "day":
		// Scan day directories: reports/YYYY/MM/DD/
		// For day summaries, we need to scan all days that might contain summaries
		// that overlap with the query range. Since a day summary covers [day 00:00:00, next_day 00:00:00),
		// we need to include all days from start date to end date (inclusive)
		// Also need to include the day that contains the end time, since a day summary
		// starting on that day would end the next day and might overlap with the query range
		current := time.Date(start.Year(), start.Month(), start.Day(), 0, 0, 0, 0, start.Location())
		endDate := time.Date(end.Year(), end.Month(), end.Day(), 0, 0, 0, 0, end.Location())
		// Include all days from start to end (inclusive)
		for !current.After(endDate) {
			year := current.Format("2006")
			month := current.Format("01")
			day := current.Format("02")
			dirs = append(dirs, filepath.Join(s.reportsPath, year, month, day))
			current = current.AddDate(0, 0, 1)
		}

	case "hour":
		// Scan hour directories: reports/YYYY/MM/DD/HH/
		current := start
		for current.Before(end) || current.Equal(end) {
			year := current.Format("2006")
			month := current.Format("01")
			day := current.Format("02")
			hour := current.Format("15")
			dirs = append(dirs, filepath.Join(s.reportsPath, year, month, day, hour))
			current = current.Add(time.Hour)
			if current.After(end) {
				break
			}
		}

	case "fifteenmin", "halfhour":
		// Scan hour directories: reports/YYYY/MM/DD/HH/
		current := start
		for current.Before(end) || current.Equal(end) {
			year := current.Format("2006")
			month := current.Format("01")
			day := current.Format("02")
			hour := current.Format("15")
			dirPath := filepath.Join(s.reportsPath, year, month, day, hour)
			// Check if already added
			found := false
			for _, d := range dirs {
				if d == dirPath {
					found = true
					break
				}
			}
			if !found {
				dirs = append(dirs, dirPath)
			}
			current = current.Add(time.Hour)
			if current.After(end) {
				break
			}
		}

	case "work-segment":
		// Scan day directories: reports/YYYY/MM/DD/
		current := start
		for current.Before(end) || current.Equal(end) {
			year := current.Format("2006")
			month := current.Format("01")
			day := current.Format("02")
			dirs = append(dirs, filepath.Join(s.reportsPath, year, month, day))
			current = current.AddDate(0, 0, 1)
		}

	case "week":
		// Scan month directories: reports/YYYY/MM/
		current := start
		for current.Before(end) || current.Equal(end) {
			year := current.Format("2006")
			month := current.Format("01")
			dirPath := filepath.Join(s.reportsPath, year, month)
			// Check if already added
			found := false
			for _, d := range dirs {
				if d == dirPath {
					found = true
					break
				}
			}
			if !found {
				dirs = append(dirs, dirPath)
			}
			current = current.AddDate(0, 1, 0)
			if current.After(end) {
				break
			}
		}

	case "month":
		// Scan month directories: reports/YYYY/MM/
		current := start
		for current.Before(end) || current.Equal(end) {
			year := current.Format("2006")
			month := current.Format("01")
			dirPath := filepath.Join(s.reportsPath, year, month)
			// Check if already added
			found := false
			for _, d := range dirs {
				if d == dirPath {
					found = true
					break
				}
			}
			if !found {
				dirs = append(dirs, dirPath)
			}
			current = current.AddDate(0, 1, 0)
			if current.After(end) {
				break
			}
		}

	case "year":
		// Scan year directories: reports/YYYY/
		current := start
		for current.Before(end) || current.Equal(end) {
			year := current.Format("2006")
			dirPath := filepath.Join(s.reportsPath, year)
			// Check if already added
			found := false
			for _, d := range dirs {
				if d == dirPath {
					found = true
					break
				}
			}
			if !found {
				dirs = append(dirs, dirPath)
			}
			current = current.AddDate(1, 0, 0)
			if current.After(end) {
				break
			}
		}
	}

	return dirs
}
